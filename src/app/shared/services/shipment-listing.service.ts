import {Injectable} from '@angular/core';
import {HttpService, StatusStyleMapping, MilestoneViewModes} from '../index';
import {Shipment} from '../../pages/dashboard/shipment-listing/shipment.model';
import {STATUSES} from '../../pages/trackings/enums/statuses';
import { CalculationService } from "./calculation.service";

@Injectable()
export class ShipmentListingService {

  private STATUS_STYLES_MAPING = StatusStyleMapping;
  private STATUSES = STATUSES;
  private MILESTONE_VIEW_MODES = MilestoneViewModes;

  private GET_SHIPMENTS_URL = 'Shipments';
  private GET_LOCATION_URL = 'Locations';
  private GET_SHIPMENT_UNITS_URL = 'ShipmentUnits';
  private GET_MILESTONE_URL = 'MilestoneTypes';
  private GET_ROUTESTAGES_URL = 'RouteStages';

  private GET_SHOCK_EVENTS_URL = 'ShockEvents';
  private GET_TEMPERATURE_EVENTS_URL = 'TemperatureEvents';
  private GET_HUMIDITY_EVENTS_URL = 'HumidityEvents';

  constructor(private calculationService: CalculationService,
              private httpService: HttpService) {
  }

  /**
   * Returns an array of promises. For each entry a promise has to
   * be resolved, because some properties of a shipment are requested separately
   *
   * @param {Array<any>} data
   * @returns {Array<Promise<any>>}
   */
  private shipmentListResponseHandler(data: Array<any>): Array<Promise<any>> {
    return data.map(shipment => {
      return this.createSingleShipment(shipment);
    });
  }

  /**
   * Gets the shipmentList from backend, then runs the response trough shipmentListResponseHandler
   * and resolves the array of promises generated by it.
   *
   * @returns {Promise<any>}
   */
  public getShipmentList(): Promise<any> {
    return new Promise((resolve, reject) => {
      this.httpService.get(this.GET_SHIPMENTS_URL).map(response => {
        let shipment1 = response[0]; 
        shipment1.truckId="truck0";
        let shipment2 = response[1];
        shipment2.truckId="truck1";
        let shipment3 = response[2];
        shipment3.truckId="truck2";
       let myarray = [shipment1, shipment2, shipment3];
        return this.shipmentListResponseHandler(myarray);
      }).toPromise().then(arrayOfPromises => {
        resolve(Promise.all(arrayOfPromises));
      }).catch(error => {
        reject(error);
      });
    })
  }

  /**
   * Returns a promise with the requested location by id
   * @param {string} id
   * @returns {Promise<any>}
   */
  public getLocationById(id: string) {
    return this.httpService.get(`${this.GET_LOCATION_URL}/${id}`).toPromise();
  }

  /**
   * Gets the id of the originLocation from the shipment, makes a request
   * to get the location object and resolves a Promise when ready
   * @param shipment
   * @returns {Promise<any>}
   */
  private setFromLocation(shipment): Promise<any> {
    return new Promise((resolve, reject) => {
      let originLocationId;
      try {
        originLocationId = shipment['associations'].filter(element => element.relnName === 'originLocation')[0].data[0]._id;
      } catch (error) {
        originLocationId = '';
      }
      resolve(this.getLocationById(originLocationId));
    });
  }

  /**
   * Gets the id of the destinationLocation from the shipment, makes a request
   * to get the location object and resolves a Promise when ready
   * @param shipment
   * @returns {Promise<any>}
   */
  private setToLocation(shipment): Promise<any> {
    return new Promise((resolve, reject) => {
      let originLocationId;
      try {
        originLocationId = shipment['associations'].filter(element => element.relnName === 'destinationLocation')[0].data[0]._id;
      } catch (error) {
        originLocationId = '';
      }
      resolve(this.getLocationById(originLocationId));
    });
  }

  /**
   * Returns an array with the statuses of each milestone ordered hronologicaly
   * @param shipment
   * @returns {Array<any>}
   */
  private calculateStatus(shipment): Array<any> {
    try {
      const routeStages = shipment.embedded.filter(elem => elem.parentRelnName === 'routeStages')[0].entities;
      const statusesArray = [];
      routeStages.forEach(routeStage => {
        const milestones = routeStage.embedded.filter(elem => elem.parentRelnName === 'milestones')[0].entities;
        milestones.forEach(milestone => statusesArray.push(this.STATUS_STYLES_MAPING[milestone.MilestoneStatus]));
      });
      return statusesArray;
    } catch (error) {
      return [];
    }
  }

  /**
   * Calls the setFromLocation and setToLocation methods on the shipment, waiting all to be resolved,
   * then constructs an Shipment object and resolves it
   * @param shipment
   * @returns {Promise<any>}
   */
  private createSingleShipment(shipment): Promise<any> {
    console.log('shipment');
    console.log(shipment);
    return new Promise((resolve, reject) => {
      Promise.all([this.setFromLocation(shipment), this.setToLocation(shipment)]).then(data => {
        shipment.originLocation = data[0].Name;
        shipment.destinationLocation = data[1].Name;
        shipment.status = this.calculateStatus(shipment);
        shipment.truckId = shipment.truckId;
        console.log(shipment.truckId);
        resolve(new Shipment(shipment));
      }).catch(error => {
        resolve({});
      });
    })
  }

  /**
   * Makes a request for a specific shipment by id
   * @param {string} shipmentId
   * @returns {Promise<any>}
   */
  public getShipmentById(shipmentId: string): Promise<any> {
    return this.httpService.get(`${this.GET_SHIPMENTS_URL}/${shipmentId}`).toPromise();
  }

  /**
   * Makes a request for shipmentUnits for the specified shipment by id
   * @param {string} shipmentId
   * @returns {Promise<any>}
   */
  public getShipmentUnits(shipmentId: string): Promise<any> {
    return this.httpService.get(`${this.GET_SHIPMENTS_URL}/${shipmentId}/${this.GET_SHIPMENT_UNITS_URL}`).toPromise();
  }

  /**
   * Gets the routeStages for the supplied unit (Shipment or ShipmentUnit)
   * @param data
   * @returns {Promise<any>}
   */
  public getRouteStages(data: any): Promise<any> {
    const baseUrl = data.type === this.MILESTONE_VIEW_MODES.shipment ? this.GET_SHIPMENTS_URL : this.GET_SHIPMENT_UNITS_URL;
    return this.httpService.get(`${baseUrl}/${data.id}/${this.GET_ROUTESTAGES_URL}`).toPromise();
  }

  /**
   * Gets the routestages, then goes through every routeStage and every Milestone
   * and makes a requests to set the neccessary data for the milestone View
   * and resolves all the data
   * @param unit
   * @returns {Promise<any>}
   */
  public getDataForMilestoneView(unit: any): Promise<any> {
    const me = this;
    return new Promise((resolve, reject) => {
      this.getRouteStages(unit).then(routeStages => {
        const arrayOfPromises = [];

        // check if routeStages comming from Backend is actually array
        routeStages = Array.isArray(routeStages) ? routeStages : [];

        // construct arrayOfpromises with entry for every routeStage
        routeStages.forEach(routeStage => {
          arrayOfPromises.push(this.prepareRouteStage(routeStage));
        });
        // wait for all the promises to get the data and set it for each milestone
        Promise.all(arrayOfPromises).then(data => {
          data.forEach((routeStage, routeStageIndex) => {
            routeStage.forEach((milestone, milestoneIndex) => {
              milestone = milestone || {};
              const currentMilestone = routeStages[routeStageIndex].milestones[milestoneIndex];
              currentMilestone.location = milestone[1];
              currentMilestone.milestoneType = milestone[0] ? milestone[0].name || '' : '';
              currentMilestone.icon = me.STATUSES[currentMilestone.milestoneType][me.STATUS_STYLES_MAPING[currentMilestone.MilestoneStatus]];
              currentMilestone.delayEvent = milestone[2];
            })
          });

          resolve(routeStages);
        })
      }).catch(error => {
        console.error(error);
        resolve(null)
      })
    })
  }

  /**
   *  Goes trough every milestone in a routeStage and calls the prepareMilestone function
   *  returns a promise
   * @param routeStage
   * @returns {Promise<any>}
   */
  private prepareRouteStage(routeStage): Promise<any> {
    try {
      routeStage.milestones = routeStage.embedded.filter(elem => elem.parentRelnName === 'milestones')[0].entities;
      const eventHistory = routeStage.embedded.filter(elem => elem.parentRelnName === 'eventHistory')[0].entities;
      routeStage.rerouteEvent = eventHistory.filter(event => event.type === 'ReroutingEvent')[0];
      console.log('Here: ', routeStage.rerouteEvent);
    } catch (error) {
      routeStage.milestones = [];
      routeStage.rerouteEvent = null;
    }
    const arrayOfPromises = [];
    routeStage.milestones.forEach(milestone => {
      arrayOfPromises.push(this.prepareMilestone(milestone));
    });
    return Promise.all(arrayOfPromises);
  }

  /**
   * Calls the neccesary requests for single milestone and returns a promise
   * @param milestone
   * @returns {Promise<any>}
   */
  private prepareMilestone(milestone): Promise<any> {
    let milestoneId;
    let locationId;
    try {
      milestoneId = milestone.associations.filter(elem => elem.relnName === 'milestoneType')[0].data[0]._id;
      locationId = milestone.associations.filter(elem => elem.relnName === 'location')[0].data[0]._id;
    } catch (error) {
      milestoneId = 0;
      locationId = 0
    }
    if (!milestoneId || !locationId) {
      return;
    }
    return Promise.all([this.getMilestoneById(milestoneId), this.getLocationById(locationId), this.checkMilestoneForDelayEvent(milestone)]);
  }

  /**
   * Searches for delay events and resolves the first one found
   * @param milestone
   * @returns {Promise<any>}
   */
  private checkMilestoneForDelayEvent(milestone: any): Promise<any> {
    let delayEvent;
    try {
      delayEvent = milestone.embedded.filter(elem => elem.parentRelnName === 'eventHistory')[0].entities.filter(elem => elem.type === 'DelayEvent')[0];
      delayEvent.dataString = this.calculationService.generateTimeFormatByMinutes(delayEvent.DelayDuration)
    } catch (error) {
      delayEvent = null;
    }
    return new Promise((resolve, reject) => {
      resolve(delayEvent);
    })

  }

  /**
   * Makes a request for a milestone by Id
   * @param {string} milestoneId
   * @returns {Promise<any>}
   */
  public getMilestoneById(milestoneId: string): Promise<any> {
    return this.httpService.get(`${this.GET_MILESTONE_URL}/${milestoneId}`).toPromise();
  }

  /**
   * Makes a request for shipmentUnit by id
   * @param {string} shipmentUnitId
   * @returns {Promise<any>}
   */
  public getShipmentUnitById(shipmentUnitId: string): Promise<any> {
    return this.httpService.get(`${this.GET_SHIPMENT_UNITS_URL}/${shipmentUnitId}`).toPromise();
  }

  /**
   * Requests the sensor data from the backend
   * @param {string} shipmentUnitId
   * @returns {Promise<any>}
   */
  public getSensorData(shipmentUnitId: string): Promise<any> {
    const shipmentUnitUrl = `${this.GET_SHIPMENT_UNITS_URL}/${shipmentUnitId}`;
    return Promise.all([
      this.httpService.get(`${shipmentUnitUrl}/${this.GET_SHOCK_EVENTS_URL}`).toPromise(),
      this.httpService.get(`${shipmentUnitUrl}/${this.GET_TEMPERATURE_EVENTS_URL}`).toPromise(),
      this.httpService.get(`${shipmentUnitUrl}/${this.GET_HUMIDITY_EVENTS_URL}`).toPromise()
    ]);
  }
}